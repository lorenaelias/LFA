class AFP:
    def __init__(self, nomeArq):
        with open(nomeArq, 'r') as arq:
            self.Q     = arq.readline().strip().split(' ')                 #  Estados
            self.S     = arq.readline().strip().split(' ')                 #  Alfabeto de símbolos
            self.T     = arq.readline().strip().split(' ')                 #  Alfabeto da pilha
            self.Z     = arq.readline().strip()                            #  Simbolo inicial da pilha
            self.q0    = arq.readline().strip()                            #  Estado inicial
            self.F     = arq.readline().strip().split(' ')                 #  Estados Finais
            self.pilha = [self.Z]                                          #  Pilha do automato

            # TODO: IMPLEMENTAR DELTA
            # TODO: IMPLEMENTAR EFECHO E CORRIGIR A FUNÇÃO DE PERCORRIMENTO DA CADEIA

            self.delta = {}                                             #  Sintaxe: (Simbolo, Estado atual, Topo da pilha) -> (Estados / Ação da pilha)

            transicoes = arq.read().split('\n')
            for i in range(len(transicoes)):
                transicoes[i] = transicoes[i].split(' / ')
                transicoes[i][0] = transicoes[i][0].strip().split(' ')
                print(transicoes[i])
            

            for i in transicoes:
                self.delta[(i[0][0], i[0][1], i[0][2])] = (i[0][2:][1:], i[1])


    def __str__(self):
        Q  = 'Q  -> '   + str(self.Q)
        S  = '\nS  -> ' + str(self.S)
        T = '\nT -> ' + str(self.T)
        Z  = '\nZ  -> ' + str(self.Z)
        q0 = '\nq0 -> ' + str(self.q0)
        F  = '\nF  -> ' + str(self.F)

        print(Q, S, T, Z, q0, F)

        for i in self.delta:
            print(i, ' -> ', self.delta[i])

        return ''

    def efecho(self, estado):
        lista = []
        for i in self.delta:
            if i[0] == '&':
                lista.append( (i[1], self.delta[i]) )          # A lista gerada possui a seguinte forma: [(estado, destino)]
        print(lista)

    
    
    def percorreCadeia(self, cadeia, estadoAtual, pilha):
        if cadeia == '':
            return estadoAtual in self.F or pilha == []
        
        carAtual = cadeia[0]
        if pilha == []: return cadeia == ''
        verEstado = (carAtual, estadoAtual, pilha[-1])
        print('verEstado -> ', verEstado)

        if verEstado in self.delta:
            proxEstado = self.delta[verEstado]
            print('ProxEstado -> ', proxEstado, end='\n\n\n')

            if proxEstado[1] == '&': pilha.pop()
            if len(proxEstado[1]) == 2: pilha.append(proxEstado[1][1])
            if pilha == []: return cadeia == ''

            print('pilha -> ', pilha)
            for estado in proxEstado:
                if estado not in proxEstado[0]:
                    print('Backtracking!')
                    print(verEstado, ' -> ', end='')
                print(estado, '\t', type(estado))

                if self.percorreCadeia(cadeia[1:], estado[0], pilha):
                    return True

        return False